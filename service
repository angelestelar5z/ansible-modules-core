#!/usr/bin/python

# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.

try:
    import json
except ImportError:
    import simplejson as json
import sys
import shlex
import subprocess

# ===========================================

SERVICE = '/sbin/service'

def _run(cmd):
    ''' :Return: A tuple of ``(returncode, stdout, stderr)`` resulting from executing
    `cmd` with the shell. '''
    process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
    stdout, stderr = process.communicate()
    return (process.returncode, stdout, stderr) 


argfile = sys.argv[1]
args = open(argfile, 'r').read()
items = shlex.split(args)

if not len(items):
    print json.dumps(dict(failed=True, msg='this module requires arguments (-a)'))
    sys.exit(1)

params = {}
for arg in items:
    if "=" not in arg:
        print json.dumps(dict(failed=True, msg='expected arguments of the form name=value'))
        sys.exit(1)
    (name, value) = arg.split("=")
    params[name] = value

name = params['name']
state = params.get('state','unknown')
list_ = params.get('list')

# running and started are the same
if state not in [ 'running', 'started', 'stopped', 'restarted' ]:
    print json.dumps(dict(failed=True, msg='invalid state'))
    sys.exit(1)
if list_ and list_ not in ('status',):
    print json.dumps(dict(failed=True, msg='invalid argument to list'))
    sys.exit(1)
    

# ===========================================
# get service status

rc, stdout, stderr = _run("%s %s status" % (SERVICE, name))

# ===========================================
# determine if we are going to change anything

running = False
if stdout.find("not running") != -1:
    running = False
elif stdout.find("running") != -1:
    running = True
elif name == 'iptables' and stdout.find("ACCEPT") != -1:
    # iptables status command output is lame
    # TODO: lookup if we can use a return code for this instead?
    running = True

changed = False
if not running and state == "started":
    changed = True
elif running and state == "stopped":
    changed = True
elif state == "restarted":
    changed = True

# ===========================================
# run change commands if we need to


rc = 0
if changed:
    if state in ('started', 'running'):
        rc, stdout, stderr = _run("%s %s start" % (SERVICE, name))
    elif state == 'stopped':
        rc, stdout, stderr = _run("%s %s stop" % (SERVICE, name))
    elif state == 'restarted':
        rc1, stdout1, stderr1 = _run("%s %s stop" % (SERVICE, name))
        rc2, stdout2, stderr2 = _run("%s %s start" % (SERVICE, name))
        rc = rc1 and rc2
        stdout = stdout1 + stdout2
        stderr = stderr1 + stderr2

if rc != 0:
    print json.dumps({
        "failed" : 1,
        "rc"     : rc,
    })
    print >> sys.stderr, stdout + stderr
    sys.exit(1)


# ===============================================
# success

result = {"changed": changed}

if list_ == 'status':
    rc, stdout, stderr = _run("%s %s status" % (SERVICE, name))
    result['status'] = stdout
    
print json.dumps(result)

